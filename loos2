import numpy as np
from dataprocessing import *
import tensorflow as tf

def loss_function(box1, box2, w_xy, angles_true, angles_pre):
    # Flatten the boxes to 2D arrays
    i, j = np.indices((40, 40))
    offset = i * 8

    left1, top1, right1, down1 = box1[..., 0], box1[..., 1], box1[..., 2], box1[..., 3]
    left2, top2, right2, down2 = box2[..., 0], box2[..., 1], box2[..., 2], box2[..., 3]

    left1 = left1 - 4 + offset
    top1 = top1 + 4 + offset
    right1 = right1 + 4 + offset
    down1 = down1 - 4 + offset

    left2 = left2 - 4 + offset
    top2 = top2 + 4 + offset
    right2 = right2 + 4 + offset
    down2 = down2 - 4 + offset
    box1_flat = tf.stack([left1, top1, right1, down1], axis=-1)
    box2_flat = tf.stack([left2, top2, right2, down2], axis=-1)
    box1_flat = tf.cast(box1_flat, dtype=tf.float32)
    box2_flat = tf.cast(box2_flat, dtype=tf.float32)
    box1_flat = tf.reshape(box1_flat, [-1, 4])
    box2_flat = tf.reshape(box2_flat, [-1, 4])
    mask = tf.reduce_any(tf.not_equal(box1_flat, 0), axis=-1)
    indices = tf.where(mask)
    box1_flat = tf.gather_nd(box1_flat, indices)
    box2_flat = tf.gather_nd(box2_flat, indices)

    w_xy_flat = tf.reshape(w_xy, [-1])
    w_xy_flat = tf.gather_nd(w_xy_flat,indices)

    # Compute the intersection and union
    h = tf.maximum(0.0, tf.minimum(box1_flat[:,3],box2_flat[:,3]) - tf.maximum(box1_flat[:,1],box2_flat[:,1]))
    w = tf.maximum(0.0, tf.minimum(box1_flat[:,2],box2_flat[:,2]) - tf.maximum(box1_flat[:,0],box2_flat[:,0]))
    intersection = h * w
    area1 = (box1_flat[:, 2] - box1_flat[:, 0]) * (box1_flat[:, 3] - box1_flat[:, 1])
    area2 = (box2_flat[:, 2] - box2_flat[:, 0]) * (box2_flat[:, 3] - box2_flat[:, 1])
    union = area1 + area2 - intersection
    iou = tf.where(tf.equal(union, 0.0), tf.zeros_like(union), intersection / union)

    # Compute the L_reg term
    x1, y1, x2, y2 = tf.unstack(box1_flat, axis=1)
    x3, y3, x4, y4 = tf.unstack(box2_flat, axis=1)
    C = tf.sqrt(tf.square(tf.maximum(tf.maximum(tf.maximum(x1, x2), x3), x4) - tf.minimum(tf.minimum(tf.minimum(x1, x2), x3), x4)) + \
                tf.square(tf.maximum(tf.maximum(tf.maximum(y1, y2), y3), y4) - tf.minimum(tf.minimum(tf.minimum(y1, y2), y3), y4)))
    point_1 = tf.stack([(x1+x2)/2, (y1+y2)/2], axis=1)
    point_2 = tf.stack([(x3+x4)/2, (y3+y4)/2], axis=1)
    D = tf.sqrt(tf.square(point_2[:, 0]-point_1[:, 0]) + tf.square(point_2[:, 1]-point_1[:, 1]))
    lens = tf.square(D) / tf.square(C)
    diou = iou - lens
    L_reg = (1 - diou) * tf.cast(w_xy_flat, dtype=tf.float32)
    L_reg_sum = tf.reduce_sum(L_reg)

    Npos = np.count_nonzero(box1)
    Lcls_sum = np.zeros((box1.shape[0], 40,40,18))

    for k in range(angles_true.shape[-1]):
        if angles_true[...,k].any():
            Lcls_true = 0.25*((1-angles_pre[...,k])**2)*np.log(angles_pre[...,k])
        
            Lcls_false = 0.75*((angles_pre[...,k])**2)*np.log(1-angles_pre[...,k])
            Lcls_sum[...,k] = -(Lcls_true*angles_true[...,k] + Lcls_false*(1-angles_true[...,k]))


    Lcls = tf.reduce_sum(Lcls_sum)/ Npos
    Lcls = tf.cast(Lcls,tf.float32)
    L_reg = 2/Npos*L_reg_sum
    L = Lcls + L_reg
    return L
